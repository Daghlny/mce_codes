!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BUFF_SIZE	inputbuffer.hpp	8;"	d
BZ__HPP	inputbuffer.hpp	3;"	d
CPP_FILES	unitTest/makefile	/^CPP_FILES = ..\/mce.cpp ..\/inputbuffer.cpp$/;"	m
FillInputBuffer	inputbuffer.cpp	/^inputbuffer::FillInputBuffer(char *pos)$/;"	f	class:inputbuffer
INCLUDE	unitTest/makefile	/^INCLUDE = -I ..\/$/;"	m
MCE__HPP	mce.hpp	3;"	d
P	bk.hpp	/^    vid *P;$/;"	m	struct:node_t
P	bk.hpp	/^    vid *P;$/;"	m	struct:task_t
Plen	bk.hpp	/^    vid Plen;$/;"	m	struct:node_t
Plen	bk.hpp	/^    vid Plen;$/;"	m	struct:task_t
R	bk.hpp	/^    vid *R;$/;"	m	struct:node_t
R	bk.hpp	/^    vid *R;$/;"	m	struct:task_t
Rlen	bk.hpp	/^    vid Rlen;$/;"	m	struct:node_t
Rlen	bk.hpp	/^    vid Rlen;$/;"	m	struct:task_t
X	bk.hpp	/^    vid *X;$/;"	m	struct:node_t
X	bk.hpp	/^    vid *X;$/;"	m	struct:task_t
Xlen	bk.hpp	/^    vid Xlen;$/;"	m	struct:node_t
Xlen	bk.hpp	/^    vid Xlen;$/;"	m	struct:task_t
__MCE__H__	bk.hpp	3;"	d
add_task	bfs_mce.cpp	/^add_task(vid *newR, vid *newP, vid *newX, vid newRlen, vid newPlen, vid newXlen)$/;"	f
binary_search	mce.cpp	/^binary_search(vtype &vl, vid v)$/;"	f
bk_recur_process	bk.cpp	/^bk_recur_process(const vtype *G, node_t &father, FILE *outfile)$/;"	f
buff	inputbuffer.hpp	/^        char *buff;         \/\/ points to the input buffer memory area$/;"	m	class:inputbuffer
child_mce_process	bfs_mce.cpp	/^child_mce_process(task_t T, const vtype *G, const vid &nodenum, FILE *outfile)$/;"	f
compute_cliques	bfs_mce.cpp	/^compute_cliques(const vtype *G, const vid &nodenum, FILE *outfile)$/;"	f
compute_cliques	bk.cpp	/^compute_cliques(const vtype *G, const vid &nodenum, FILE *outfile)$/;"	f
curpos	inputbuffer.hpp	/^        char *curpos;       \/\/ first position of bytes not readed$/;"	m	class:inputbuffer
data	mce.hpp	/^    vtype *data;$/;"	m	struct:graph_t
deg	bk.hpp	/^    vid deg;$/;"	m	struct:vtype
deg	mce.hpp	/^    vid deg;$/;"	m	struct:vtype
endpos	inputbuffer.hpp	/^        char *endpos;       \/\/ last position of bytes needing to be read$/;"	m	class:inputbuffer
file	inputbuffer.hpp	/^        FILE *file;         \/\/ corressponding file pointer$/;"	m	class:inputbuffer
get_neibor_sg	mce.cpp	/^get_neibor_sg(graph_t &g, graph_t &sg, vid vertex)$/;"	f
get_neighbor_cc	mce.cpp	/^get_neighbor_cc(graph_t &g, vid vertex, vector<vid> &cc)$/;"	f
get_vertex_dd_map	mce.cpp	/^get_vertex_dd_map(vector<vid> &ddvertex, vid& degeneracy, map<vid, vid> &ddmap, inputbuffer &ddbuffer)$/;"	f
getline	inputbuffer.cpp	/^inputbuffer::getline(char *&start, char *&end)$/;"	f	class:inputbuffer
getoffset	inputbuffer.hpp	/^inputbuffer::getoffset(char *start)$/;"	f	class:inputbuffer
getsize	inputbuffer.cpp	/^inputbuffer::getsize(){$/;"	f	class:inputbuffer
graph_t	mce.hpp	/^        graph_t():data(NULL), nodenum(0){};$/;"	f	struct:graph_t
graph_t	mce.hpp	/^struct graph_t $/;"	s
init_g	mce.hpp	/^graph_t::init_g(FILE *gfile)$/;"	f	class:graph_t
init_g_withddmap	mce.cpp	/^init_g_withddmap(graph_t &g, FILE *gfile, map<vid,vid> &ddmap)$/;"	f
inputbuffer	inputbuffer.hpp	/^        inputbuffer(FILE *infile):$/;"	f	class:inputbuffer
inputbuffer	inputbuffer.hpp	/^        inputbuffer(size_t s, FILE *infile):$/;"	f	class:inputbuffer
inputbuffer	inputbuffer.hpp	/^class inputbuffer$/;"	c
intersect	bfs_mce.cpp	/^intersect(vid *&newP, vid *&newX, vid &newPlen, vid &newXlen, task_t T, vid v, const vtype *G)$/;"	f
intersect	bk.cpp	/^intersect(vid *&newP, vid *&newX, vid &newPlen, vid &newXlen, node_t &father, vid v, const vtype *G)$/;"	f
key	mce.hpp	/^    vid key;$/;"	m	struct:vtype
main	bk.cpp	/^main(int argc, char **argv)$/;"	f
main	bkMain.cpp	/^main(int argc, char **argv)$/;"	f
main	mce.cpp	/^main(int argc, char **argv)$/;"	f
main	unitTest/read_graph_test.cpp	/^main(int argc, char **argv)$/;"	f
mark_cc	mce.cpp	/^mark_cc(graph_t &g, vid v, int *labels, int label)$/;"	f
nbv	bk.hpp	/^    vid *nbv;$/;"	m	struct:vtype
nbv	mce.hpp	/^    vid *nbv;$/;"	m	struct:vtype
node_t	bk.hpp	/^    node_t(vid *newR, vid *newP, vid *newX, $/;"	f	struct:node_t
node_t	bk.hpp	/^struct node_t$/;"	s
nodenum	mce.hpp	/^    vid   nodenum;$/;"	m	struct:graph_t
operator []	mce.hpp	/^graph_t::operator[] (const vid index) const$/;"	f	class:graph_t
operator []	mce.hpp	/^graph_t::operator[] (const vid index)$/;"	f	class:graph_t
output_clique	bfs_mce.cpp	/^output_clique(task_t T, FILE *outfile)$/;"	f
output_clique	bk.cpp	/^output_clique(node_t &node, FILE *outfile)$/;"	f
print_graph	unitTest/read_graph_test.cpp	/^print_graph(vtype *G, vid nodenum)$/;"	f
print_task	bfs_mce.cpp	/^print_task(task_t T)$/;"	f
read_graph	bfs_mce.cpp	/^read_graph(vtype *&G, vid &nodenum, FILE *infile)$/;"	f
read_graph	bk.cpp	/^read_graph(vtype *&G, vid &nodenum, FILE *infile)$/;"	f
size	inputbuffer.hpp	/^        size_t size;        \/\/ input buffer size, default 1MB(1024*1024)$/;"	m	class:inputbuffer
task_t	bk.hpp	/^struct task_t$/;"	s
totalclique	bk.cpp	/^size_t totalclique = 0;$/;"	v
vIt	mce.hpp	/^typedef vector<vid>::iterator vIt;$/;"	t
vid	bk.hpp	/^typedef int vid;$/;"	t
vid	mce.hpp	/^typedef int vid;$/;"	t
vtype	bk.hpp	/^struct vtype$/;"	s
vtype	mce.hpp	/^struct vtype$/;"	s
wcc	mce.cpp	/^wcc(graph_t &g, vector<int> &cc)$/;"	f
~graph_t	mce.hpp	/^graph_t::~graph_t()$/;"	f	class:graph_t
~inputbuffer	inputbuffer.cpp	/^inputbuffer::~inputbuffer()$/;"	f	class:inputbuffer
~node_t	bk.hpp	/^    ~node_t()$/;"	f	struct:node_t
